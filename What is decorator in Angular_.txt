![Imgur](https://i.imgur.com/2C8tCgo.jpg)

## What is a decorator in Angular?
Decorator is a declarative way of providing metadata information to typescript compiler. It is declared by `@.`

>NOTEâ€ƒ Decorators are an experimental feature that may change in future releases.

As per the Typescript

Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. Decorators are a [stage 2 proposal](https://github.com/tc39/proposal-decorators) for JavaScript and are available as an experimental feature of TypeScript.

## How to enable decorator?

To enable experimental support for decorators, you must enable the `experimentalDecorators` compiler option either on the command line or in your `tsconfig.json`:
```json
{
    "compilerOptions": {
        "target": "ES6",
        "experimentalDecorators": true
    }
}
```
## Types of decorator

There are four types of decorator in Angular
1. Class Decorator
2. Method Decorator
3. Field Decorator
4. Parameter Decorator

### Class Decorator
Angular provide some class level decorator like `Component` and `NgModule` .
``` javascript
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  data:boolean=false;
}
```
### Field Decorator
Angular offers some field-level decorator like `@Input` and `@Output.`
``` javascript
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
 @Input() data:Array<any>;
}

```
### Method Decorator
Angular offers some method level decorator like `HostBinding` and `HostListener.`

```javascript

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  @HostListener('mouseover')
  onMouseOver($event){
    
  }
}
```
### Parameter Decorator
Angular  offers some parameter level decorator like `@Inject.`

```javascript
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

    constructor(@Inject(SomeService) service){

    }
  }
  ```
  
  ### Execution order of decorator

As per the typescript website, There is a well-defined order to how decorators applied to various declarations inside of a class are utilised:

1.  _Parameter Decorators_, followed by  _Method_,  _Accessor_, or  _Property Decorators_, is used for each instance member.
2.  _Parameter Decorators_, followed by  _Method_,  _Accessor_, or  _Property Decorators_  are used for each static member.
3.  _Parameter Decorators_  are used for the constructor.
4.  _Class Decorators_  are used for the class.


  ## How to create custom decorator in Angular
  You can create your decorator if your requirement doesn't fit with existing decorator
  ###  Method Decorator
  Let's suppose you want to benchmark your function in Angular. In the naive approach, you can wrap your function in start and end time and then you can calculate the time. This approach will work, but it requires a lot of changes in your code.  The second and best approach is the declarative way. Just create a custom decorator and add an annotation to your method.
  
  For example, take the following example.
  
  ```javascript
  function benchMark(): MethodDecorator {
  return function(target: Function, key: string, descriptor: any) {
    const originalMethod = descriptor.value;
    descriptor.value = function(...args: any[]) {
      const start = new Date().getTime();
      const result = originalMethod.apply(this, args);
      const end = new Date().getTime();
      console.log(` ${key} execute in  ${(end - start) / 1000} ms`);

      return result;
    };
    return descriptor;
  };
}
```
And you can use the above decorator as shown below

``` typescript
import { Component } from "@angular/core";

function benchMark(): MethodDecorator {
  return function(target: Function, key: string, descriptor: any) {
    const originalMethod = descriptor.value;
    descriptor.value = function(...args: any[]) {
      const start = new Date().getTime();
      const result = originalMethod.apply(this, args);
      const end = new Date().getTime();
      console.log(` ${key} execute in  ${(end - start) / 1000} ms`);

      return result;
    };
    return descriptor;
  };
}

@Component({
  selector: "my-app",
  templateUrl: "./app.component.html",
  styleUrls: ["./app.component.css"]
})
export class AppComponent {
  name = "Angular";

  @benchMark()
  ngOnInit() {
    this.doSomeWork();
  }
  doSomeWork() {
    for (let i = 0; i < 10000000; i++) {}
  }
}
```

![](https://1.bp.blogspot.com/-WC4hR1PcV8U/XqaVUNXdbeI/AAAAAAAAMQk/21YjEUg8oPgfkvtzERSU_BbdoLEOKFWQACLcBGAsYHQ/s640/method_decorator.png)


### Class Decorator
Let's consider you want to add `createdDate` and `updatedDate` to every model of your application for auditing purpose. In this case, you can create a class decorator.
See the below code for the implementation of the class decorator. 


```javascript
function auditLog<T extends { new (...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    createdDate = new Date();
  };
}
@auditLog
export class User {
  firstName: string;
  lastName: string;
  constructor(firstName: string, lastName: string) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
}
```

How to use
```javascript
import { Component, OnInit } from "@angular/core";

function auditLog<T extends { new (...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    createdDate = new Date();
  };
}
@auditLog
export class User {
  firstName: string;
  lastName: string;
  constructor(firstName: string, lastName: string) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
}

@Component({
  selector: "app-class",
  templateUrl: "./class.component.html",
  styleUrls: ["./class.component.css"]
})
export class ClassComponent implements OnInit {
  constructor() {}

  ngOnInit() {
    const user = new User("John", "Doe");
    console.log(JSON.stringify(user));
  }
}
```

<a href="https://1.bp.blogspot.com/-TBQTPSP3nK8/XqaVVM2n4bI/AAAAAAAAMQw/wyW5opbmucMyE_v03-zyVbgx5bwk8OsrQCPcBGAYYCw/s1600/class_decorator.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="193" data-original-width="811" src="https://1.bp.blogspot.com/-TBQTPSP3nK8/XqaVVM2n4bI/AAAAAAAAMQw/wyW5opbmucMyE_v03-zyVbgx5bwk8OsrQCPcBGAYYCw/s1600/class_decorator.png" /></a>


<!--stackedit_data:
eyJwcm9wZXJ0aWVzIjoidGFnczogYW5ndWxhci1pbnRlcnZpZX
dcbnRpdGxlOiBXaGF0IGlzIGRlY29yYXRvciBpbiBBbmd1bGFy
XG4iLCJoaXN0b3J5IjpbLTU2MTg5MjU1Nyw2MjY1NDczMDQsMT
I4MzkxMjQ1LDIwNDA1ODA3MSwyMDAxMTUxNTQ3LDEwMTIxOTcx
OCwxNDI4MzcwODA5LC0xNTgwNzM3OTkxLC01ODg3MjQ5OTQsMT
I5NTgyNTA3MCwxNjIxNzc3MzU3LC0xOTc3MjU4NzI1LC0xNTc2
MDI1MzgxLDg4Mzg4MDE2MywxMTE4NjA3NzQsMTI5MjUxMDgxOS
wxMjQyNjQ4NTkwLDM0Nzc2MTM5Ml19
-->