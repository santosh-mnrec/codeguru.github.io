[TOC]

## NET Core DI, ways of passing parameters to the constructor

  

> This technique is useful when not all the parameters for the constructor can be created from the container. Whilst some of the parameters can be created, they need to be configured before being consumne b the constructor

In this post, I will show you how to pass parameters to the constructor of the service while resolving the dependency.  
Let’s consider you have legacy code and you want to use it in our .net core application. The code is accepting some constructor parameters which .net container DI cannot inject.
Let’s create a console application to demonstrate this.

> Main.cs

```csharp
void Main()
{
	var container = Startup.Configure();
	var customerService = container.GetService<ICustomerService>();
	customerService.GetData();

}

```

> Startup.cs

```csharp
public class Startup
{


	public static ServiceProvider Configure()
	{
		var provider = new ServiceCollection()
					.AddScoped<IDataService,DataService>()
					.AddLogging(fs => fs.AddConsole())
					.AddTransient<ICustomerService, CustomerService>()

					.BuildServiceProvider();
		return provider;
	}

}

```

> IDataService

```csharp
public interface IDataService
{
	void GetData();
}

public interface ICustomerService
{
	void GetData();
}

```

> DataService.cs

```csharp
public class DataService : IDataService
{
	private readonly ILogger _logger;
	private readonly string _connectionString;

	public DataService(ILogger<DataService> logger, string connectionString)
	{
		_logger = logger;
		_connectionString = connectionString;

	}

	public void GetData()
	{
		_logger.LogInformation($"Getting Data From DataBase {_connectionString}");

	}

}

```

> CustomerService

```csharp
public class CustomerService : ICustomerService
{
	private readonly ILogger<CustomerService> _logger;
	private readonly IDataService _dataService;
	public CustomerService(ILoggerFactory loggerFactory, IDataService dataService)
	{
		_logger = loggerFactory.CreateLogger<CustomerService>();
		_dataService = dataService;
	}

	public void GetData()
	{
		_dataService.GetData();
	}
}

```

If you run the application, you will get the following error because  `DataService` expects a connection string parameter. After all, that service is not resolved.

> Unable to resolve service for type ‘System. String’ while attempting to activate ‘DataService’.

To solve this issue, we can use the  `factory delegate`  of  `IServiceProvider`.

Let’s add the  `factory delegate.`

![](https://lh3.googleusercontent.com/-D8z3lSAU_QA/YKjhE2MNUII/AAAAAAAAOp0/iqi4fIwwuH435TCW9kyftL58fWhDtDomACLcBGAsYHQ/w640-h136/image.png)

```csharp
public class Startup
{


	public static ServiceProvider Configure()
	{
		var provider = new ServiceCollection()
					.AddScoped<IDataService>(x =>
					{
						var logger = x.GetRequiredService<ILogger<DataService>>();
						var dataService = new DataService(logger, "some conection string");
						return dataService;

					})
					.AddLogging(fs => fs.AddConsole())
					.AddTransient<ICustomerService, CustomerService>()

					.BuildServiceProvider();
		return provider;
	}

}

```

If you run the application, you will get the output.

> info: DataService[0]  
> Getting Data From DataBase some conection string

  

  

-   [.Net Core dependency injection in the console app](https://www.codeguru.co.in/2021/05/net-core-dependency-injection-in.html)
-   [.Net Core dependency injection multiple implementations](https://www.codeguru.co.in/2021/05/net-core-dependency-injection-multiple.html)
-   [Captive Dependency in .NET Core](https://www.codeguru.co.in/2021/05/captive-dependency-in-net-core.html)
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwOTc0MjU0NzBdfQ==
-->