  
In this post I will discuss how to use `anonymous` and `lambda` expression in .net.

Imagine we have a simple example in c# that simply add two numbers.

  
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

class Program
{
    public delegate int Fn(int a, int b);
    static void Main(string[] args)
    {
        Fn add = new Fn(Add);
        Console.WriteLine(add(1, 2));
    }
    public static int Add(int a, int b)
    {
        return (a + b);
    }
} 
```
  

Let’s refactor the `delegate` instance version of the code to use an anonymous method.

## What is anonymous method?

Anonymous methods are a new language feature in C# 2.0. Anonymous methods allow us to define a code block where a delegate object is acceptable.

_Let’s convert the above code using anonymous code._

Remove the following method from the delegate instance version
```csharp
public static int Add(int a, int b)
{
	return (a + b);
}
```

And replace following code with
```csharp
Fn add = new Fn(Add);
```
With this one.
```csharp
Fn add = delegate(int a,int b)
            { return (a+b);
            }; 
```
  
Now we can write code as shown below to use the above defined class using anonymous method as follows:

  
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;


    class Program
    {
        public delegate int Fn(int a, int b);
        static void Main(string[] args)
        {
1.    Fn add = delegate(int a, int b)
2.    {
3.    return (a + b);
4.    };

            Console.WriteLine(add(1, 2));
        }

    }

  ```

Let’s go further and refactor our code using Lambda Expression.

## What is lambda expression?

Lambda expression is inline methods that are part of the Linq technology and converted to delegates or an expression tree at compile time. Its use => operator to separate method. Meaning of => operator is  **goes to**  i.e. if you have a c# statement **x=>x+y then**  you read this statement as  **x goes to x+y**.
Go to the line 1 and remove the ==delegate== keyword.
 
```csharp
   Fn add = (int a, int b)
            {
                return (a + b);
           };
           ```
And place lambda sign => after method signature. 
```csharp
   Fn add = (int a, int b)=>
            {
                return (a + b);
         };
```
  

So this final lambda expression version code looks something like this.
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;


    class Program
    {
        public delegate int Fn(int a, int b);
        static void Main(string[] args)
        {
            Fn add = (int a, int b) =>
            {
                return (a + b);
            };

            Console.WriteLine(add(1, 2));
        }

    }
```
  
  

I have summarized the above discussion into following image.

[![](http://2.bp.blogspot.com/_iY3Ra2OqpkA/TIursUCfVWI/AAAAAAAACPE/Oxh-VisvFLM/s640/lambda.jpg  "Lambda expression")](https://www.blogger.com/blog/post/edit/6673695286148904603/1665877940644256783#)
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTQ4NzIwOTYyLDE0Nzc1NzUzNTBdfQ==
-->